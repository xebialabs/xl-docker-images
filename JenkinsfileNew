#!groovy
@Library('jenkins-pipeline-libs@master')
import java.lang.Object
import com.xebialabs.pipeline.utils.Branches
import groovy.transform.Field

pipeline {
    agent none

    parameters {
        choice(
                name: 'product',
                choices: ['xl-client', 'xl-release', 'xl-deploy', 'deploy-task-engine', 'central-configuration'],
                description: 'Select the product you want to generate docker image for')
        string(
                name: 'version',
                defaultValue: '',
                description: "Version of the product you want to create Docker Images for (leave empty for latest)")
        string(
                name: 'branch',
                defaultValue: 'master',
                description: "Git branch to build from")
        choice(
                name: 'targetOs',
                choices: ['all', 'ubuntu', 'redhat'],
                description: "Target OS for docker images")
        choice(
                name: 'releaseType',
                choices: ['nightly', 'final'],
                description: "Type of Release if it is nightly or final. Dockerfiles will be committed only for final releases to xebialabs registry.")
        choice(
                name: 'registry',
                choices: ['xebialabsunsupported', 'xebialabs', 'xebialabsearlyaccess', 'xldevdocker'],
                description: "Docker registry where docker images will be pushed to")
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '20', artifactDaysToKeepStr: '7', artifactNumToKeepStr: '5'))
        timeout(time: 1, unit: 'HOURS')
        timestamps()
        ansiColor('xterm')
    }

    environment {
        NEXUS_CRED = credentials('nexus-ci')
    }

    stages {

        stage('Determine Product Version') {
            agent none
            steps {
                script {
                    // Determine product version incase of PR build or user did not provide one for latest version
                    env.PRODUCT_VERSION = getLatestVersion(params.product)
                    echo "Using product version: ${env.PRODUCT_VERSION} for all stages"
                }
            }
        }

        stage('Rendering and Build Docker Images for Products') {
            when {
                expression {
                    (params.targetOs == 'all' || params.targetOs in ['ubuntu', 'redhat'])
                }
            }
            agent {
                label 'docker_linux'
            }
            steps {
                // Clean old workspace
                step([$class: 'WsCleanup'])

                // Checkout from specified branch
                checkout([$class: 'GitSCM',
                    branches: [[name: "*/${params.branch}"]],
                    userRemoteConfigs: scm.userRemoteConfigs
                ])

                // Clean docker images including volumes
                sh '''
                    docker rm -f $(docker ps -a -q) 2>/dev/null || echo "No more containers to remove."
                    docker rmi $(docker images -q) 2>/dev/null || echo "No more images to remove."
                    docker system prune -a --volumes -f 2>/dev/null || echo "No more data to prun."
                '''

                // install pipenv and needed dependencies
                sh 'pipenv install'

                // Rendering and Committing changes
                script {
                    def productVersion = env.PRODUCT_VERSION
                    def targetOsList = getTargetOsList(params.targetOs, params.product)

                    // Add --commit flag only for final releases to xebialabs registry
                    def commitFlag = ((params.releaseType == "final") && (params.registry == "xebialabs")) ? '--commit' : ''
                    sh "pipenv run ./applejack.py render --xl-version ${productVersion} --product ${params.product} --registry ${params.registry} ${commitFlag}"

                    // Build Docker Image and push it
                    def targetOsArgs = (params.product == 'xl-client') ? '--target-os alpine' : targetOsList.collect { "--target-os ${it}" }.join(' ')
                    sh "pipenv run ./applejack.py build --xl-version ${productVersion} --download-source nexus --download-username ${NEXUS_CRED_USR} --download-password ${NEXUS_CRED_PSW} --product ${params.product} ${targetOsArgs} --push --registry ${params.registry}"
                }
                script {
                    cleanWs()
                }
            }
        }

        stage('Test Docker Images') {
            parallel {
                stage('Test Docker Images for Ubuntu') {
                    when {
                        expression {
                            (params.targetOs == 'all' || params.targetOs == 'ubuntu')
                        }
                    }
                    agent {
                        label 'docker_linux'
                    }
                    steps {
                        script {
                            def productVersion = env.PRODUCT_VERSION
                            testDockerImage(params.product, productVersion, params.registry, 'ubuntu')
                        }
                        script {
                            cleanWs()
                        }
                    }
                }

                stage('Test Docker Images for Redhat') {
                    when {
                        expression {
                            (params.targetOs == 'all' || params.targetOs == 'redhat')
                        }
                    }
                    agent {
                        label 'docker_linux'
                    }
                    steps {
                        script {
                            def productVersion = env.PRODUCT_VERSION
                            testDockerImage(params.product, productVersion, params.registry, 'redhat')
                        }
                        script {
                            cleanWs()
                        }
                    }
                }
            }
        }
    }
    post {
        success {
            script {
                if (env.BRANCH_NAME == 'master') {
                    slackSend color: "good", tokenCredentialId: "slack-token", message: "XL Official Docker Images build *SUCCESS* - <${env.BUILD_URL}|click to open>", channel: 'docker-images-release'
                }
            }
        }
        failure {
            script {
                if (env.BRANCH_NAME == 'master') {
                    slackSend color: "danger", tokenCredentialId: "slack-token", message: "XL Official Docker Images build *FAILED* - <${env.BUILD_URL}|click to open>", channel: 'docker-images-release'
                }
            }
        }
    }
}

/**
 * Determines product version - uses specified version, fetches latest if no version specified,
 * or fetches latest version corresponding to PR builds.
 *
 * @return The resolved product version string
 */
def getLatestVersion(xl_product) {
    script {
        // Use provided version first incase of pipeline job with build parameters
        if (params.version != '') {
            echo "Using explicitly provided version: ${params.version}"
            return params.version
        }

        // Determine target branch (PR target branch or default to master when no version param provided)
        def targetBranch = env.CHANGE_TARGET ?: env.ghprbTargetBranch ?: 'master'
        echo "Determining latest version for ${xl_product} targeting branch: ${targetBranch}"

        def groupId = getGroupId(xl_product)
        def artifactId = getArtifactId(xl_product)
        def versionPattern = getVersionForNexusSearch(targetBranch)

        def productVersion = getLatestVersionFromNexus(groupId, artifactId, versionPattern)

        if (!productVersion) {
            error("No version found for ${xl_product} corresponding to branch ${targetBranch}. Cannot proceed with build.")
        }

        echo "Selected version ${productVersion} for ${xl_product} targeting branch ${targetBranch}"
        return productVersion
    }
}

/**
 * Determines the specific major.minor version to search nexus based on target branch.
 * 
 * Returns branch name (e.g., "25.3" of current repo) for maintenance branches to search for "25.3.*" versions.
 * Returns null for master/other branches to get latest available version.
 */
def getVersionForNexusSearch(targetBranch) {
    return (targetBranch ==~ /^\d+\.\d+$/) ? targetBranch : null
}

def getLatestVersionFromNexus(groupId, artifactId, versionPattern) {
    def searchUrl = "https://nexus.xebialabs.com/nexus/service/local/lucene/search?g=${groupId}&a=${artifactId}"

    if (versionPattern) {
        searchUrl += "&v=${versionPattern}*"
        echo "Searching for versions matching: ${versionPattern}.*"
    }

    def versionCmd = """
        curl -su \${NEXUS_CRED} '${searchUrl}' 2>/dev/null | \\
        grep -o '<version>[^<]*</version>' | \\
        sed 's/<version>\\(.*\\)<\\/version>/\\1/' | \\
        sort -V | \\
        tail -1
    """

    def version = sh(script: versionCmd, returnStdout: true).trim()

    return version
}

def getGroupId(xl_product) {
    switch(xl_product) {
        case 'xl-client':
            return 'com.xebialabs.xlclient'
        case 'xl-release':
            return 'com.xebialabs.xlrelease'
        case 'xl-deploy':
            return 'com.xebialabs.deployit'
        case 'central-configuration':
            return 'ai.digital.config'
        case 'deploy-task-engine':
            return 'com.xebialabs.deployit'
        default:
            error("Unknown product: ${xl_product}")
    }
}

def getArtifactId(xl_product) {
    switch(xl_product) {
        case 'xl-client':
            return 'xl-client'
        case 'xl-release':
            return 'xl-release'
        case 'xl-deploy':
            return 'xl-deploy'
        case 'central-configuration':
            return 'central-configuration-server'
        case 'deploy-task-engine':
            return 'xl-deploy'  // Uses same artifact as xl-deploy
        default:
            error("Unknown product: ${xl_product}")
    }
}

def getTargetOsList(target_os, product) {
    def osList = []

    if (target_os == 'all') {
        if (product == 'xl-client') {
            osList = ['alpine']
        } else {
            osList = ['ubuntu', 'redhat']
        }
    } else if (target_os in ['ubuntu', 'redhat']) {
        osList = [target_os]
    }

    return osList
}

def testDockerImage(product, productVersion, registry, targetOs) {
    // Get product-specific test configuration
    def config = getProductTestConfig(product, productVersion, registry, targetOs)

    if (config.dockerCmd) {
        // Run Docker container
        def status = sh(script: config.dockerCmd, returnStatus: true)

        // Check if container started successfully
        if (status != 0) {
            currentBuild.result = 'FAILURE'
            error("Docker container failed to start: ${registry}/${product}:${productVersion}-${targetOs}")
        }

        // Wait for service to be ready and test if accessible (if test URL provided)
        if (config.testUrl) {
            sh "sleep 100"
            def pstatus = sh(script: "curl ${config.testUrl}", returnStatus: true)

            // Check if service is accessible
            if (pstatus != 0) {
                currentBuild.result = 'FAILURE'
                error("Service is not accessible in container: ${registry}/${product}:${productVersion}-${targetOs}")
            }
        }
    }
}

/**
 * Provides the configuration to test for given product viz. docker command and test URL
 * @return Map containing 'dockerCmd' and 'testUrl' keys
 */
def getProductTestConfig(product, productVersion, registry, targetOs) {
    def config = [:]
    def imageSuffix = (targetOs == 'redhat') ? '-redhat' : ''
    def portOffset = (targetOs == 'redhat') ? 1 : 0  // Add 1 to port for redhat to avoid conflicts

    switch(product) {
        case 'xl-release':
            def hostPort = 6616 + portOffset
            config.dockerCmd = "docker run -d -e ADMIN_PASSWORD=admin -e ACCEPT_EULA=Y -p ${hostPort}:5516 --name xl-release-${targetOs} ${registry}/xl-release:${productVersion}${imageSuffix}"
            config.testUrl = "localhost:${hostPort}"
            break
        case 'xl-deploy':
            def hostPort = 5616 + portOffset
            config.dockerCmd = "docker run -d -e ADMIN_PASSWORD=admin -e ACCEPT_EULA=Y -p ${hostPort}:4516 --name xl-deploy-${targetOs} ${registry}/xl-deploy:${productVersion}${imageSuffix}"
            config.testUrl = "localhost:${hostPort}"
            break
        case 'central-configuration':
            def hostPort = 8888 + portOffset
            config.dockerCmd = "docker run -d -p ${hostPort}:8888 --name central-configuration-${targetOs} ${registry}/central-configuration:${productVersion}${imageSuffix}"
            config.testUrl = "localhost:${hostPort}"
            break
        case 'deploy-task-engine':
            def hostPort = 9180 + portOffset
            config.dockerCmd = "docker run -d -p ${hostPort}:8180 --name deploy-task-engine-${targetOs} ${registry}/deploy-task-engine:${productVersion}${imageSuffix}"
            config.testUrl = null // No URL test for this product
            break
        default:
            config.dockerCmd = null
            config.testUrl = null
    }

    return config
}
