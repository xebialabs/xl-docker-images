#!groovy
@Library('jenkins-pipeline-libs@master')
import java.lang.Object
import com.xebialabs.pipeline.utils.Branches
import groovy.transform.Field

pipeline {
    agent none

    parameters {
        choice(
                name: 'product',
                choices: ['xl-client', 'xl-release', 'xl-deploy', 'deploy-task-engine', 'central-configuration'],
                description: 'Select the product you want to generate Docker Image for')
        string(
                name: 'version',
                defaultValue: '',
                description: "Version of the product you want to create Docker Images for (leave empty for latest)")
        string(
                name: 'branch',
                defaultValue: 'master',
                description: "Git branch to build from")
        choice(
                name: 'targetOs',
                choices: ['all', 'ubuntu', 'redhat'],
                description: "Target OS for Docker Images")
        choice(
                name: 'releaseType',
                choices: ['nightly', 'final'],
                description: "Type of Release if it is nightly or final")
        choice(
                name: 'registry',
                choices: ['xldevdocker', 'xebialabs', 'xebialabsunsupported', 'xebialabsearlyaccess'],
                description: "Docker Registry you want to push Docker Images to")
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '20', artifactDaysToKeepStr: '7', artifactNumToKeepStr: '5'))
        timeout(time: 1, unit: 'HOURS')
        timestamps()
        ansiColor('xterm')
    }

    environment {
        NEXUS_CRED = credentials('nexus-ci')
        SEED_VERSION = '9.6.1-alpha.4'
    }

    stages {

        stage('Rendering and Build Docker Images for XLProducts') {
            when {
                expression {
                    (params.targetOs == 'all' || params.targetOs in ['ubuntu', 'redhat'])
                }
            }
            agent {
                label 'docker_linux'
            }
            steps {
                // Clean old workspace
                step([$class: 'WsCleanup'])

                // Checkout from specified branch
                checkout([$class: 'GitSCM',
                    branches: [[name: "*/${params.branch}"]],
                    userRemoteConfigs: scm.userRemoteConfigs
                ])

                // Clean docker images including volumes
                sh '''
                    docker rm -f $(docker ps -a -q) 2>/dev/null || echo "No more containers to remove."
                    docker rmi $(docker images -q) 2>/dev/null || echo "No more images to remove."
                    docker system prune -a --volumes -f 2>/dev/null || echo "No more data to prun."
                '''

                // install pipenv and needed dependencies
                sh 'pipenv install'

                // Rendering and Committing changes
                script {
                    def productVersion = getLatestVersion(params.product)
                    def targetOsList = getTargetOsList(params.targetOs, params.product)

                    if ((params.releaseType == "final") && (params.registry == "xebialabs")) {
                        sh "pipenv run ./applejack.py render --xl-version ${productVersion} --product ${params.product} --registry ${params.registry} --commit"
                    } else {
                        sh "pipenv run ./applejack.py render --xl-version ${productVersion} --product ${params.product} --registry ${params.registry}"
                    }

                    // Build Docker Image and push it
                    if (params.product == 'xl-client') {
                        sh "pipenv run ./applejack.py build --xl-version ${productVersion} --download-source nexus --download-username ${NEXUS_CRED_USR} --download-password ${NEXUS_CRED_PSW} --product ${params.product} --target-os alpine --push --registry ${params.registry}"
                    } else {
                        def targetOsArgs = targetOsList.collect { "--target-os ${it}" }.join(' ')
                        sh "pipenv run ./applejack.py build --xl-version ${productVersion} --download-source nexus --download-username ${NEXUS_CRED_USR} --download-password ${NEXUS_CRED_PSW} --product ${params.product} ${targetOsArgs} --push --registry ${params.registry}"
                    }
                }
                script {
                    cleanWs()
                }
            }
        }

        stage('Test Docker Images for XLProducts') {
            parallel {
                stage('Test Docker Images for Ubuntu') {
                    when {
                        expression {
                            (params.targetOs == 'all' || params.targetOs == 'ubuntu')
                        }
                    }
                    agent {
                        label 'docker_linux'
                    }
                    steps {
                        script {
                            def productVersion = getLatestVersion(params.product)
                            testDockerImage(params.product, productVersion, params.registry, 'ubuntu')
                        }
                        script {
                            cleanWs()
                        }
                    }
                }

                stage('Test Docker Images for Redhat') {
                    when {
                        expression {
                            (params.targetOs == 'all' || params.targetOs == 'redhat')
                        }
                    }
                    agent {
                        label 'docker_linux'
                    }
                    steps {
                        script {
                            def productVersion = getLatestVersion(params.product)
                            testDockerImage(params.product, productVersion, params.registry, 'redhat')
                        }
                        script {
                            cleanWs()
                        }
                    }
                }
            }
        }
    }
    post {
        success {
            script {
                if (env.BRANCH_NAME == 'master') {
                    slackSend color: "good", tokenCredentialId: "slack-token", message: "XL Official Docker Images build *SUCCESS* - <${env.BUILD_URL}|click to open>", channel: 'docker-images-release'
                }
            }
        }
        failure {
            script {
                if (env.BRANCH_NAME == 'master') {
                    slackSend color: "danger", tokenCredentialId: "slack-token", message: "XL Official Docker Images build *FAILED* - <${env.BUILD_URL}|click to open>", channel: 'docker-images-release'
                }
            }
        }
    }
}

def getLatestVersion(xl_product) {
    script {
        // Use provided version or get latest from nexus
        if (params.version != '') {
            return params.version
        }

        def productVersion = ""

        switch(xl_product) {
            case 'xl-client':
                productVersion = sh(script: 'curl -su ${NEXUS_CRED} https://nexus.xebialabs.com/nexus/service/local/repositories/releases/content/com/xebialabs/xlclient/xl-client/maven-metadata.xml | grep "<release>" | cut -d ">" -f 2 | cut -d "<" -f 1 | sort -n | tail -1', returnStdout: true).trim()
                break
            case 'xl-release':
                productVersion = sh(script: 'curl -su ${NEXUS_CRED} https://nexus.xebialabs.com/nexus/service/local/repositories/releases/content/com/xebialabs/xlrelease/xl-release/maven-metadata.xml | grep "<release>" | cut -d ">" -f 2 | cut -d "<" -f 1 | sort -n | tail -1', returnStdout: true).trim()
                break
            case 'xl-deploy':
                productVersion = sh(script: 'curl -su ${NEXUS_CRED} https://nexus.xebialabs.com/nexus/service/local/repositories/releases/content/com/xebialabs/deployit/xl-deploy/maven-metadata.xml | grep "<release>" | cut -d ">" -f 2 | cut -d "<" -f 1 | sort -n | tail -1', returnStdout: true).trim()
                break
            case 'central-configuration':
                productVersion = sh(script: 'curl -su ${NEXUS_CRED} https://nexus.xebialabs.com/nexus/service/local/repositories/releases/content/ai/digital/config/central-configuration-server/maven-metadata.xml | grep "<release>" | cut -d ">" -f 2 | cut -d "<" -f 1 | sort -n | tail -1', returnStdout: true).trim()
                break
            case 'deploy-task-engine':
                productVersion = sh(script: 'curl -su ${NEXUS_CRED} https://nexus.xebialabs.com/nexus/service/local/repositories/releases/content/com/xebialabs/deployit/xl-deploy/maven-metadata.xml | grep "<release>" | cut -d ">" -f 2 | cut -d "<" -f 1 | sort -n | tail -1', returnStdout: true).trim()
                break
            default:
                error("Unknown product: ${xl_product}")
        }

        writeFile(file: "${env.WORKSPACE}/${xl_product}-latest", text: "${productVersion}")
        return productVersion
    }
}

def getTargetOsList(target_os, product) {
    def osList = []

    if (target_os == 'all') {
        if (product == 'xl-client') {
            osList = ['alpine']
        } else {
            osList = ['ubuntu', 'redhat']
        }
    } else if (target_os in ['ubuntu', 'redhat']) {
        osList = [target_os]
    }

    return osList
}

def testDockerImage(product, productVersion, registry, targetOs) {
    // Get product-specific test configuration
    def config = getProductTestConfig(product, productVersion, registry, targetOs)

    if (config.dockerCmd) {
        // Run Docker container
        def status = sh(script: config.dockerCmd, returnStatus: true)

        // Check if container started successfully
        if (status != 0) {
            currentBuild.result = 'FAILURE'
            error("Docker container failed to start: ${registry}/${product}:${productVersion}-${targetOs}")
        }

        // Wait for service to be ready and test if accessible (if test URL provided)
        if (config.testUrl) {
            sh "sleep 100"
            def pstatus = sh(script: "curl ${config.testUrl}", returnStatus: true)

            // Check if service is accessible
            if (pstatus != 0) {
                currentBuild.result = 'FAILURE'
                error("Service is not accessible in container: ${registry}/${product}:${productVersion}-${targetOs}")
            }
        }
    }
}

/**
 * Provides the configuration to test for given product viz. docker command and test URL
 * @return Map containing 'dockerCmd' and 'testUrl' keys
 */
def getProductTestConfig(product, productVersion, registry, targetOs) {
    def config = [:]
    def imageSuffix = (targetOs == 'redhat') ? '-redhat' : ''
    def portOffset = (targetOs == 'redhat') ? 1 : 0  // Add 1 to port for redhat to avoid conflicts

    switch(product) {
        case 'xl-release':
            def hostPort = 6616 + portOffset
            config.dockerCmd = "docker run -d -e ADMIN_PASSWORD=admin -e ACCEPT_EULA=Y -p ${hostPort}:5516 --name xl-release-${targetOs} ${registry}/xl-release:${productVersion}${imageSuffix}"
            config.testUrl = "localhost:${hostPort}"
            break
        case 'xl-deploy':
            def hostPort = 5616 + portOffset
            config.dockerCmd = "docker run -d -e ADMIN_PASSWORD=admin -e ACCEPT_EULA=Y -p ${hostPort}:4516 --name xl-deploy-${targetOs} ${registry}/xl-deploy:${productVersion}${imageSuffix}"
            config.testUrl = "localhost:${hostPort}"
            break
        case 'central-configuration':
            def hostPort = 8888 + portOffset
            config.dockerCmd = "docker run -d -p ${hostPort}:8888 --name central-configuration-${targetOs} ${registry}/central-configuration:${productVersion}${imageSuffix}"
            config.testUrl = "localhost:${hostPort}"
            break
        case 'deploy-task-engine':
            def hostPort = 9180 + portOffset
            config.dockerCmd = "docker run -d -p ${hostPort}:8180 --name deploy-task-engine-${targetOs} ${registry}/deploy-task-engine:${productVersion}${imageSuffix}"
            config.testUrl = null // No URL test for this product
            break
        default:
            config.dockerCmd = null
            config.testUrl = null
    }

    return config
}
